<?xml version="1.0" encoding="utf-8"?>
<s:VGroup xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" xmlns:view="view.*"
		 xmlns:suportClasses="view.suportClasses.*" gap="0"
		 creationComplete="onComplete(event)">
	<fx:Metadata>
		[Event(name="propertyEditorItemMoved",type="view.suportClasses.events.PropertyEditorChangeEvent")]
	</fx:Metadata>
	<fx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import mx.containers.GridRow;
			import mx.core.IVisualElement;
			import mx.core.IVisualElementContainer;
			import mx.events.FlexEvent;
			import mx.events.ListEvent;
			
			import components.renderers.OrganizerTreeRenderer;
			
			import data.OrganizerItem;
			
			import view.interfaces.IPrimeFacesSurfaceComponent;
			import view.primeFaces.supportClasses.GridBase;
			import view.primeFaces.surfaceComponents.components.Fieldset;
			import view.primeFaces.surfaceComponents.components.Grid;
			import view.primeFaces.surfaceComponents.components.PanelGrid;
			import view.primeFaces.surfaceComponents.components.TabView;
			import view.suportClasses.PropertyChangeReference;
			
			public var editingSurface:EditingSurface;
			public var isRefreshTree:Boolean = true;
			
			[Bindable] private var components:ArrayCollection;
			
			private var foundIndepthItem:OrganizerItem;
			private var lastTopParent:Object;
			private var lastChange:PropertyChangeReference;
			
			public function loadFirstData(surface:EditingSurface):void
			{
				var tmpArr:Array = getComponentsChildren(surface);
				tree.rootContainer = (tmpArr[0] as OrganizerItem).item as IVisualElementContainer;
				components = new ArrayCollection(tmpArr);
				
				tmpArr = null;
				tree.callLater(function():void
				{
					for each (var i:Object in components)
					{
						tree.expandChildrenOf(i, true);
					}
				});
			}
			
			public function addDroppedElement(ownerComponent:IVisualElement, component:IVisualElement, droppedIndex:int=-1):void
			{
				findItemInDepth(components.source, isSubDivComponent(ownerComponent));
				this.callLater(function():void
				{
					if (foundIndepthItem) 
					{
						if (droppedIndex == -1) foundIndepthItem.children.push((component as IPrimeFacesSurfaceComponent).getComponentsChildren());
						else foundIndepthItem.children.insertAt(droppedIndex, (component as IPrimeFacesSurfaceComponent).getComponentsChildren());
					}
					else 
					{
						if (droppedIndex == -1) components.addItem((component as IPrimeFacesSurfaceComponent).getComponentsChildren());
						else components.addItemAt((component as IPrimeFacesSurfaceComponent).getComponentsChildren(), droppedIndex);
					}
					
					refreshItem(component);
					foundIndepthItem = null;
				});
			}
			
			public function removeDroppedElement(ownerComponent:IVisualElement, component:IVisualElement):void
			{
				findItemInDepth(components.source, isSubDivComponent(ownerComponent));
				this.callLater(function():void
				{
					var tmpItems:Array = foundIndepthItem ? foundIndepthItem.children : components.source; 
					for (var i:int=0; i < tmpItems.length; i++)
					{
						if (tmpItems[i].item === component)
						{
							tmpItems.splice(i, 1);
							tree.selectedIndex = -1;
							break;
						}
					}
					
					refreshItem(component);
					foundIndepthItem = null;
				});
			}
			
			public function updateItemWithPropertyChanges(change:PropertyChangeReference):void
			{
				if (!tree.selectedItem) return;
				
				if (change.fieldClass == tree.selectedItem.item)
				{
					if (lastChange && (change === lastChange || (change.eventType == lastChange.eventType && change.fieldClass === lastChange.fieldClass && change.fieldLastValue === lastChange.fieldLastValue && change.fieldName === lastChange.fieldName &&
						change.fieldNewValue === lastChange.fieldNewValue))) return;
					
					var organizerItem: OrganizerItem;
					var surfaceComponent: IPrimeFacesSurfaceComponent;
					var i:int;
					var cellIndex:int;
					
					lastTopParent = foundIndepthItem = null;
					lastChange = change;
					switch (change.fieldName)
					{
						case "addItemAt":
							if (change.fieldClass is TabView)
							{
								change.fieldClass["callLater"](function():void
								{
									organizerItem = (change.fieldClass as IPrimeFacesSurfaceComponent).getComponentsChildren(change.fieldName, (change.fieldClass as TabView).numElements - 1);
									if (organizerItem) 
									{
										tree.selectedItem.children.push(organizerItem);
										refreshItem(change.fieldClass as IVisualElement);
									}
								});
							}
							break;
						case "removeItemAt":
							tree.expandItem(tree.selectedItem, true);
							tree.selectedItem.children.splice(change.fieldLastValue.index, 1);
							refreshItem(change.fieldClass as IVisualElement);
							break;
						case "addRowAt":
							change.fieldClass["callLater"](function():void
							{
								if (change.fieldClass is Grid)
								{
									organizerItem = (change.fieldClass as IPrimeFacesSurfaceComponent).getComponentsChildren(change.fieldName, (change.fieldLastValue as GridRow));
									if (organizerItem)
									{
										tree.selectedItem.children.push(organizerItem.children[0]);
										refreshItem(change.fieldClass as IVisualElement);
									}
								}
								else if (change.fieldClass is PanelGrid)
								{
									organizerItem = (change.fieldClass as IPrimeFacesSurfaceComponent).getComponentsChildren(change.fieldName, change.fieldLastValue[change.fieldLastValue.length - 1].object);
									if (organizerItem)
									{
										tree.selectedItem.children = tree.selectedItem.children.concat(organizerItem.children);
										refreshItem(change.fieldClass as IVisualElement);
									}
								}
							});
							break;
						case "removeRowAt":
							tree.expandItem(tree.selectedItem, true);
							if (change.fieldClass is PanelGrid || change.fieldClass is Grid)
							{
								var rowItem:GridRow = (change.fieldClass is PanelGrid) ? change.fieldLastValue[0].object : change.fieldLastValue.object;
								for (i = 0; i < rowItem.numElements; i++)
								{
									surfaceComponent = (rowItem.getElementAt(i) as IVisualElementContainer).getElementAt(0) as IPrimeFacesSurfaceComponent;
									tree.selectedItem.children.some(function(item:*, index:int, array:Array):Boolean
									{
										if (surfaceComponent == item.item)
										{
											tree.selectedItem.children.splice(index, 1);
											return true;
										}
										return false;
									});
								}
								
								updateCellLabels(tree.selectedItem as OrganizerItem);
								refreshItem(change.fieldClass as IVisualElement);
							}
							break;
						case "removedAll":
							tree.expandItem(tree.selectedItem, true);
							tree.selectedItem.children = [];
							change.fieldClass["callLater"](function():void
							{
								organizerItem = (change.fieldClass as IPrimeFacesSurfaceComponent).getComponentsChildren();
								tree.selectedItem.children = organizerItem.children;
								refreshItem(change.fieldClass as IVisualElement);
							});
							break;
						case "addColumnAt":
							change.fieldClass["callLater"](function():void
							{
								if (change.fieldClass is Grid)
								{
									organizerItem = (change.fieldClass as IPrimeFacesSurfaceComponent).getComponentsChildren(change.fieldName, change.fieldLastValue.object,
										change.fieldLastValue.rowIndex, change.fieldLastValue.colIndex);
									if (organizerItem) 
									{
										if (change.fieldLastValue.rowIndex == 0) cellIndex = change.fieldLastValue.colIndex;
										else
										{
											i = 0;
											while (i <= change.fieldLastValue.rowIndex) {
												cellIndex += (change.fieldClass as GridBase).getNumColumns(i);
												i++;
											}
										}
										
										tree.selectedItem.children.splice(cellIndex - 1, 0, organizerItem);
										updateCellLabels(tree.selectedItem as OrganizerItem);
										refreshItem(change.fieldClass as IVisualElement);
									}
								}
								else if (change.fieldClass is PanelGrid)
								{
									
								}
							});
							break;
						case "removeColumnAt":
							tree.expandItem(tree.selectedItem, true);
							if (change.fieldClass is PanelGrid)
							{
								for (i = 0; i < change.fieldLastValue.length; i++)
								{
									surfaceComponent = change.fieldLastValue[i].object.getElementAt(0) as IPrimeFacesSurfaceComponent;
									tree.selectedItem.children.some(function(item:*, index:int, array:Array):Boolean
									{
										if (surfaceComponent == item.item)
										{
											tree.selectedItem.children.splice(index, 1);
											return true;
										}
										return false;
									});
								}
								
								refreshItem(change.fieldClass as IVisualElement);
							}
							else if (change.fieldClass is Grid)
							{
								surfaceComponent = change.fieldLastValue.object.getElementAt(0) as IPrimeFacesSurfaceComponent;
								tree.selectedItem.children.some(function(item:*, index:int, array:Array):Boolean
								{
									if (surfaceComponent == item.item)
									{
										tree.selectedItem.children.splice(index, 1);
										return true;
									}
									return false;
								});
								
								updateCellLabels(tree.selectedItem as OrganizerItem);
								refreshItem(change.fieldClass as IVisualElement);
							}
							break;
					}
				}
			}
			
			private function updateCellLabels(component:OrganizerItem):void
			{
				var numRows:int;
				var cellIndex:int;
				var gridBase:GridBase;
				
				if (component.item is Grid) gridBase = component.item as GridBase;
				else if (component.item is PanelGrid) gridBase = (component.item as PanelGrid).body;
				
				numRows = gridBase.getNumRows();
				for (var i:int=0; i < numRows; i++)
				{
					var numCols:int = gridBase.getNumColumns(i);
					for (var j:int=0; j < numCols; j++)
					{
						component.children[cellIndex].name = "R"+ (i+1) +":C"+ (j+1);
						cellIndex++;
					}
				}
			}
			
			private function onComplete(event:FlexEvent):void
			{
				editingSurface.addEventListener(Event.CHANGE, onItemSelectedOnEditingSurface, false, 0, true);
			}
			
			private function getComponentsChildren(surface:EditingSurface):Array
			{
				var element:IPrimeFacesSurfaceComponent = surface.getElementAt(0) as IPrimeFacesSurfaceComponent;
				var componentsArray:Array = [];				
				var container:IVisualElementContainer = surface;
				var organizerItem:OrganizerItem;
				var elementCount:int = 0;
				
				if (element is IPrimeFacesSurfaceComponent) container = element as IVisualElementContainer;
				if (!container)
				{
					elementCount = surface.numElements;
					container = surface;
				}
				else
				{
					elementCount = container.numElements;
				}
				
				for (var i:int = 0; i < elementCount; i++)
				{
					element = container.getElementAt(i) as IPrimeFacesSurfaceComponent;
					
					if (element === null)
					{
						continue;
					}
					
					organizerItem = element.getComponentsChildren();
					if (organizerItem) componentsArray.push(organizerItem);
				}
				
				return [new OrganizerItem(container, "Stage", componentsArray)];
			}
			
			private function findItemInDepth(items:Array, ownerComponent:IVisualElement, topParent:Object=null):void
			{
				// probable termination
				if (foundIndepthItem) return;
				
				for each (var oItem:OrganizerItem in items)
				{
					if (oItem.item === ownerComponent)
					{
						lastTopParent = topParent;
						foundIndepthItem = oItem;
						return;
					}
					else if (oItem.children && (oItem.children.length > 0) && !foundIndepthItem) 
					{
						if (items === components.source) topParent = oItem;
						findItemInDepth(oItem.children, ownerComponent, topParent);
					}
				}
			}
			
			private function refreshItem(item:IVisualElement=null, invalidateEverything:Boolean=true):void
			{
				var tmpFoundItemInDepth:OrganizerItem = (tree.selectedItem && tree.selectedItem.item == item) ? tree.selectedItem as OrganizerItem : null;
				
				var lastScrollPosition:Number = tree.verticalScrollPosition;
				var lastSelectedItem:Object = tree.selectedItem;
				var lastSelectedIndex:int = tree.selectedIndex;
				var openItems:Object = tree.openItems;

				tree.openItems = openItems;
				tree.invalidateList();
				
				if (!isRefreshTree || !item) return;
				
				lastTopParent = foundIndepthItem = null;
				this.callLater(function():void
				{
					if (!tmpFoundItemInDepth) findItemInDepth(components.source, item);
					else foundIndepthItem = tmpFoundItemInDepth;
					if (foundIndepthItem)
					{
						if (!tree.getParentItem(foundIndepthItem)) tree.expandChildrenOf(lastTopParent, true);
						
						tree.selectedItem = foundIndepthItem;
						tree.scrollToIndex(tree.selectedIndex);
						
						foundIndepthItem = null;
						lastTopParent = null;
					}
					else
					{
						tree.selectedIndex = -1;
						tree.verticalScrollPosition = lastScrollPosition;
					}
				});
			}
			
			private function isSubDivComponent(value:IVisualElement):IVisualElement
			{
				if (value is TabView) return (value as TabView).div;
				else if (value is Fieldset) return (value as Fieldset).div;
				return value;
			}
			
			private function getIconForFile(object:Object):Class
			{
				return null;
			}
			
			private function onItemSelectionChanged(event:ListEvent):void
			{
				if (tree.selectedItem) editingSurface.selectedItem = tree.selectedItem.item;
			}
			
			private function onItemSelectedOnEditingSurface(event:Event):void
			{
				if (tree.selectedItem && (tree.selectedItem.item == editingSurface.selectedItem))
					return;
				
				lastTopParent = null;
				findItemInDepth(components.source, editingSurface.selectedItem as IVisualElement);
				this.callLater(function():void
				{
					if (foundIndepthItem)
					{
						if (!tree.getParentItem(foundIndepthItem)) tree.expandChildrenOf(lastTopParent, true);
						
						tree.selectedItem = foundIndepthItem;
						tree.scrollToIndex(tree.selectedIndex);
						
						foundIndepthItem = null;
						lastTopParent = null;
					}
					else
					{
						tree.selectedIndex = -1;
					}
				});
			}
			
			private function onTreeItemKeyUp(event:KeyboardEvent):void
			{
				// Delete key-press
				if (event.keyCode == 46 && tree.selectedItem)
				{
					if (tree.selectedItem.name.indexOf(":") != -1 || 
						tree.selectedItem.type == OrganizerItem.TYPE_CELL || 
						tree.selectedItem.type == OrganizerItem.TYPE_TAB) return;
					editingSurface.deleteItem(tree.selectedItem.item);
				}
			}
			
		]]>
	</fx:Script>
	
	<view:PropertyEditorHeader componentName="Organizer-"/>
	
	<suportClasses:TreeOrganizer id="tree" 
								 dataProvider="{components}"
								 width="100%" height="100%"
								 iconFunction="{getIconForFile}"
								 rollOverColor="0xe1e1e1"
								 selectionColor="0xf2a9ba"
								 verticalScrollBarStyleName="black"
								 alternatingItemColors="[0xeeeeee, 0xffffff]"
								 rowHeight="18"
								 change="onItemSelectionChanged(event)"
								 itemRenderer="{new ClassFactory(OrganizerTreeRenderer)}"
								 keyUp="onTreeItemKeyUp(event)"/>
</s:VGroup>