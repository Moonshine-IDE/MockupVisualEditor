<?xml version="1.0" encoding="utf-8"?>
<s:VGroup xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" xmlns:view="view.*"
		 xmlns:suportClasses="view.suportClasses.*" gap="0"
		 creationComplete="onComplete(event)">
	<fx:Script>
		<![CDATA[
			import flash.utils.clearTimeout;
			import flash.utils.setTimeout;
			
			import mx.collections.ArrayCollection;
			import mx.core.IVisualElement;
			import mx.core.IVisualElementContainer;
			import mx.events.FlexEvent;
			import mx.events.ListEvent;
			
			import components.renderers.OrganizerTreeRenderer;
			
			import data.OrganizerItem;
			
			import view.interfaces.IPrimeFacesSurfaceComponent;
			import view.primeFaces.surfaceComponents.components.Fieldset;
			import view.primeFaces.surfaceComponents.components.TabView;
			
			public var editingSurface:EditingSurface;
			
			[Bindable] private var components:ArrayCollection;
			
			private var foundIndepthItem:OrganizerItem;
			
			public function loadFirstData(surface:EditingSurface):void
			{
				var tmpArr:Array = getComponentsChildren(surface);
				tree.rootContainer = (tmpArr[0] as OrganizerItem).item as IVisualElementContainer;
				components = new ArrayCollection((tmpArr[0] as OrganizerItem).children);
				
				tmpArr = null;
				tree.callLater(function():void
				{
					for each (var i:Object in components)
					{
						tree.expandChildrenOf(i, true);
					}
				});
			}
			
			public function addDroppedElement(ownerComponent:IVisualElement, component:IVisualElement):void
			{
				findItemInDepth(components.source, isSubDivComponent(ownerComponent));
				this.callLater(function():void
				{
					if (foundIndepthItem) foundIndepthItem.children.push((component as IPrimeFacesSurfaceComponent).getComponentsChildren());
					else components.addItem((component as IPrimeFacesSurfaceComponent).getComponentsChildren());
					
					refreshItem(foundIndepthItem);
					foundIndepthItem = null;
				});
			}
			
			public function removeDroppedElement(ownerComponent:IVisualElement, component:IVisualElement):void
			{
				findItemInDepth(components.source, isSubDivComponent(ownerComponent));
				this.callLater(function():void
				{
					var tmpItems:Array = foundIndepthItem ? foundIndepthItem.children : components.source; 
					for (var i:int=0; i < tmpItems.length; i++)
					{
						if (tmpItems[i].item === component)
						{
							tmpItems.splice(i, 1);
							break;
						}
					}
					
					refreshItem(foundIndepthItem);
					foundIndepthItem = null;
				});
			}
			
			private function onComplete(event:FlexEvent):void
			{
				editingSurface.addEventListener(Event.CHANGE, onItemChangedInEditingSurface, false, 0, true);
			}
			
			private function getComponentsChildren(surface:EditingSurface):Array
			{
				var element:IPrimeFacesSurfaceComponent = surface.getElementAt(0) as IPrimeFacesSurfaceComponent;
				var componentsArray:Array = [];				
				var container:IVisualElementContainer = surface;
				var organizerItem:OrganizerItem;
				var elementCount:int = 0;
				
				if (element is IPrimeFacesSurfaceComponent) container = element as IVisualElementContainer;
				if (!container)
				{
					elementCount = surface.numElements;
					container = surface;
				}
				else
				{
					elementCount = container.numElements;
				}
				
				for (var i:int = 0; i < elementCount; i++)
				{
					element = container.getElementAt(i) as IPrimeFacesSurfaceComponent;
					
					if (element === null)
					{
						continue;
					}
					
					organizerItem = element.getComponentsChildren();
					if (organizerItem) componentsArray.push(organizerItem);
				}
				
				return [new OrganizerItem(container, "ROOT", componentsArray)];
			}
			
			private function findItemInDepth(items:Array, ownerComponent:IVisualElement):void
			{
				// probable termination
				if (foundIndepthItem) return;
				
				for each (var oItem:OrganizerItem in items)
				{
					if (oItem.item === ownerComponent)
					{
						foundIndepthItem = oItem;
						return;
					}
					else if (oItem.children && (oItem.children.length > 0) && !foundIndepthItem) findItemInDepth(oItem.children, ownerComponent);
				}
			}
			
			private function refreshItem(item:OrganizerItem):void
			{
				var lastScrollPosition:Number = tree.verticalScrollPosition;
				var lastSelectedItem:Object = tree.selectedItem;
				var lastSelectedIndex:int = tree.selectedIndex;
				var openItems:Object = tree.openItems;

				tree.openItems = openItems;
				tree.invalidateList();
				
				tree.callLater(function ():void
				{
					tree.verticalScrollPosition = lastScrollPosition;
				});
				
				var timeoutValue:uint = setTimeout(function():void
				{
					tree.selectedItem = lastSelectedItem;
					
					// if still there has no selection to the tree
					if (!tree.selectedItem && lastSelectedIndex != -1) tree.selectedIndex = lastSelectedIndex;
					clearTimeout(timeoutValue);
				}, 100);
			}
			
			private function isSubDivComponent(value:IVisualElement):IVisualElement
			{
				if (value is TabView) return (value as TabView).div;
				else if (value is Fieldset) return (value as Fieldset).div;
				return value;
			}
			
			private function getIconForFile(object:Object):Class
			{
				return null;
			}
			
			private function onItemSelectionChanged(event:ListEvent):void
			{
				if (tree.selectedItem) editingSurface.selectedItem = tree.selectedItem.item;
			}
			
			private function onItemChangedInEditingSurface(event:Event):void
			{
				if (tree.selectedItem && (tree.selectedItem.item == editingSurface.selectedItem))
					return;
				
				findItemInDepth(components.source, editingSurface.selectedItem as IVisualElement);
				this.callLater(function():void
				{
					if (foundIndepthItem) 
					{
						tree.selectedItem = foundIndepthItem;
						foundIndepthItem = null;
						tree.scrollToIndex(tree.selectedIndex);
					}
				});
			}
			
			private function onTreeItemKeyUp(event:KeyboardEvent):void
			{
				// Delete key-press
				if (event.keyCode == 46 && tree.selectedItem)
				{
					if (tree.selectedItem.name.indexOf(":") != -1 || 
						tree.selectedItem.type == OrganizerItem.TYPE_CELL || 
						tree.selectedItem.type == OrganizerItem.TYPE_TAB) return;
					editingSurface.deleteItem(tree.selectedItem.item);
				}
			}
			
		]]>
	</fx:Script>
	
	<view:PropertyEditorHeader componentName="Organizer"/>
	
	<suportClasses:TreeOrganizer id="tree" 
								 dataProvider="{components}"
								 width="100%" height="100%"
								 iconFunction="{getIconForFile}"
								 rollOverColor="0xe1e1e1"
								 selectionColor="0xf2a9ba"
								 verticalScrollBarStyleName="black"
								 alternatingItemColors="[0xeeeeee, 0xffffff]"
								 rowHeight="18"
								 change="onItemSelectionChanged(event)"
								 itemRenderer="{new ClassFactory(OrganizerTreeRenderer)}"
								 keyUp="onTreeItemKeyUp(event)"/>
</s:VGroup>